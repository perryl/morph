#!/usr/bin/env python
#
# Create a Baserock .lorry file for a given Python package
#
# Copyright (C) 2014  Codethink Limited
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

from __future__ import print_function

import subprocess
import requests
import json
import sys
import shutil
import tempfile

import xmlrpclib

PYPI_URL = 'http://pypi.python.org/pypi'

def fetch_package_metadata(package_name):
    return requests.get('%s/%s/json'
                        % (PYPI_URL, package_name)).json()

def is_repo(url):
    vcss = [('git', 'clone'), ('hg', 'clone'),
            ('svn', 'checkout'), ('bzr', 'branch')]

    for (vcs, vcs_command) in vcss:
        tempdir = tempfile.mkdtemp()

        p = subprocess.Popen([vcs, vcs_command, url], stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE, cwd=tempdir)

        p.wait()
        shutil.rmtree(tempdir)

        if p.returncode == 0:
            return True

    return False

# also we only allow tar urls >.>
# need a compression flag for bzip I think >.>

def get_compression(url):
    bzip = 'bzip2'
    gzip = 'gzip'
    lzma = 'lzma'

    m = {'tar.gz': gzip, 'tgz': gzip, 'tar.Z': gzip,
           'tar.bz2': bzip, 'tbz2': bzip,
           'tar.lzma': lzma, 'tar.xz': lzma, 'tlz': lzma, 'txz': lzma}

    print(url)

    ext = '.'.join(url.split('.')[-2:])
    if ext in m: return m[ext]

    ext = url.split('.')[-1:]
    if ext in m: return m[ext]

    return None

def make_tarball_lorry(name, url):
    lorry = {'type': 'tarball', 'url': url}
    compression = get_compression(url)
    if compression:
        lorry['compression'] = compression

    return "%s-tarball: { %s }" % (name, json.dumps(lorry))

def ask_user(client, xs, fn, prompt='--> '):
    for n, x in enumerate(xs, 1):
        print('[%s]: %s' % (n, fn(x)))
    print('')

    s = raw_input(prompt)
    choice = int(s) if s.isdigit() else None
    choice = choice - 1 if choice != None and choice <= len(xs) else None

    if choice == None:
        print("Invalid choice, exiting", file=sys.stderr)
        sys.exit(1)

    return choice

def filter_urls(urls):
    allowed_extensions = ['tar.gz', 'tgz', 'tar.Z', 'tar.bz2', 'tbz2',
                          'tar.lzma', 'tar.xz', 'tlz', 'txz', 'tar']

    def allowed_extension(url):
        return ('.'.join(url['url'].split('.')[-2:]) in allowed_extensions
            or url['url'].split('.')[-1:] in allowed_extensions)

    return filter(allowed_extension, urls)

def generate_lorry_from_tarball(package_name):
    client = xmlrpclib.ServerProxy(PYPI_URL)
    releases = client.package_releases(package_name)

    if len(releases) == 0:
        print("Couldn't find any releases for packge %s, exiting" % package_name)
        sys.exit(1)

    def f(release):
        return client.release_data(package_name, release)['name'] + ' ' + release

    choice = (ask_user(client, releases, f, prompt='Select release: ')
                       if len(releases) > 1 else 0)
    release_version = releases[choice]

    urls = filter_urls(client.release_urls(package_name, release_version))

    if len(urls) == 0:
        print("Couldn't get download urls for package %s with release %s, exiting"
              % (package_name, release_version), file=sys.stderr)
        sys.exit(1)

    choice = (ask_user(client, urls, lambda url: url['url'],
                       prompt='Select url: ') if len(urls) > 1 else 0)
    url = urls[choice]['url']

    return make_tarball_lorry(package_name, url)

if len(sys.argv) != 2:
    print('usage: %s python_package' % sys.argv[0], file=sys.stderr)
    sys.exit(1)

package_name = sys.argv[1]
metadata = fetch_package_metadata(package_name)
info = metadata['info']

if 'home_page' in info:
    if is_repo(info['home_page']):
        # lorry this thing
        print('not implemented yet: lorry from ', info['home_page'])
    else:
        print(generate_lorry_from_tarball(package_name))
